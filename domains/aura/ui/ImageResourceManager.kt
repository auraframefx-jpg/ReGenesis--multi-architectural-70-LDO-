
package dev.aurakai.auraframefx.aura.ui

import android.Manifest
import android.content.Context
import android.content.pm.PackageManager
import android.net.Uri
import android.util.Log
import androidx.core.content.ContextCompat
import androidx.documentfile.provider.DocumentFile
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import java.io.File
import java.io.FileOutputStream
import java.io.IOException
import java.util.UUID
import dev.aurakai.auraframefx.aura.lab.ImageTransformation // Import ImageTransformation

import dev.aurakai.auraframefx.domains.aura.lab.CustomizationPreferences
import android.graphics.Bitmap
import android.util.LruCache
 // Re-using CustomizationPreferences to store transformation as JSON

object ImageResourceManager {

    // In-memory cache for transformed Bitmaps
    private val transformedImageCache = LruCache<String, Bitmap>(4 * 1024 * 1024) // 4MB cache

    /**
     * Generates a unique cache key for a transformed image.
     * @param uri The original image URI.
     * @param transformation The transformation parameters.
     * @return A unique String key.
     */
    fun generateCacheKey(uri: Uri, transformation: ImageTransformation): String {
        return "${uri.toString()}-${transformation.hashCode()}"
    }

    /**
     * Retrieves a transformed Bitmap from the cache.
     * @param key The cache key generated by generateCacheKey.
     * @return The cached Bitmap, or null if not found.
     */
    fun getTransformedImageFromCache(key: String): Bitmap? {
        return transformedImageCache.get(key)
    }

    /**
     * Stores a transformed Bitmap in the cache.
     * @param key The cache key generated by generateCacheKey.
     * @param bitmap The Bitmap to store.
     */
    fun putTransformedImageToCache(key: String, bitmap: Bitmap) {
        transformedImageCache.put(key, bitmap)
    }



    private const val TAG = "ImageResourceManager"
    private const val IMAGE_SUBDIRECTORY = "custom_images"

    // In a real app, imageUsageMap would track internal URIs and their associated transformations
    // For this demonstration, we'll store transformations alongside the URI in preferences.

    /**
     * Copies an image from a given Uri to the app-specific internal storage and stores its transformation.
     * Generates a unique filename for the stored image.
     * @param context The application context.
     * @param sourceUri The Uri of the image to copy.
     * @param usageKey A key to track the usage of this image (e.g., "header_image", "nav_drawer_background").
     * @param transformation The ImageTransformation object to store with the image.
     * @return The Uri of the newly copied image in internal storage, or null if copy fails.
     */
    suspend fun copyImageToInternalStorage(
        context: Context,
        sourceUri: Uri,
        usageKey: String,
        transformation: ImageTransformation
    ): Uri? {
        return withContext(Dispatchers.IO) {
            if (!hasReadExternalStoragePermission(context)) {
                Log.e(TAG, "Permission denied: READ_EXTERNAL_STORAGE needed to copy image from $sourceUri.")
                // In a real app, you would request permission here or fail gracefully
                return@withContext null
            }

            val appSpecificDir = File(context.filesDir, IMAGE_SUBDIRECTORY)
            if (!appSpecificDir.exists()) {
                appSpecificDir.mkdirs()
            }

            val uniqueFileName = "${UUID.randomUUID()}.jpg"
            val destinationFile = File(appSpecificDir, uniqueFileName)

            try {
                context.contentResolver.openInputStream(sourceUri)?.use {
                    inputStream ->
                    FileOutputStream(destinationFile).use {
                        outputStream ->
                        inputStream.copyTo(outputStream)
                    }
                }
                val internalUri = Uri.fromFile(destinationFile)
                Log.d(TAG, "Image copied to internal storage: $internalUri")

                // Store the internal URI and transformation using CustomizationPreferences
                // (assuming CustomizationPreferences has methods for this, or will be extended)
                // For demonstration, we'll simulate this by adding a helper method to CustomizationPreferences
                CustomizationPreferences.saveImageWithTransformation(context, usageKey, internalUri, transformation)

                // Note: The direct tracking via imageUsageMap in this file will be removed in favor of CustomizationPreferences
                // The deleteImageIfOrphaned logic will need to be refactored to query preferences.

                return@withContext internalUri
            } catch (e: IOException) {
                Log.e(TAG, "Failed to copy image from $sourceUri to internal storage: ${e.message}")
                return@withContext null
            } catch (e: SecurityException) {
                Log.e(TAG, "Security exception when accessing image $sourceUri: ${e.message}. Ensure permissions or URI access is correct.")
                return@withContext null
            }
        }
    }

    /**
     * Deletes an image from internal storage if it's no longer referenced in preferences.
     * This method would need to iterate through all relevant preference keys to ensure it's not in use.
     * For simplicity, this is a placeholder.
     * @param context The application context.
     * @param imageUri The Uri of the image to potentially delete.
     */
    fun deleteImageIfOrphaned(context: Context, imageUri: Uri) {
        val filePath = imageUri.path ?: return
        val file = File(filePath)

        // In a full implementation, you'd check all preference keys that store image URIs
        // to confirm if this imageUri is truly orphaned.
        // For now, this acts as a simple file deletion assuming it's safe to delete.
        if (file.exists() && file.delete()) {
            Log.d(TAG, "Image file deleted from internal storage: $imageUri")
        } else {
            Log.w(TAG, "Failed to delete image file or file not found: $imageUri")
        }
    }

    /**
     * Cleans up all orphaned images not currently referenced in any customization preferences.
     * This is a more comprehensive cleanup.
     */
    fun cleanupOrphanedImages(context: Context) {
        val appSpecificDir = File(context.filesDir, IMAGE_SUBDIRECTORY)
        if (!appSpecificDir.exists()) return

        // In a real implementation, you would gather all URIs from CustomizationPreferences
        // and then delete files in IMAGE_SUBDIRECTORY that are not in that set.
        val referencedUris = CustomizationPreferences.getAllReferencedImageUris(context)

        appSpecificDir.listFiles()?.forEach {
            file ->
            val fileUri = Uri.fromFile(file)
            if (fileUri !in referencedUris) {
                if (file.delete()) {
                    Log.d(TAG, "Cleaned up untracked image: $fileUri")
                } else {
                    Log.w(TAG, "Failed to delete untracked image: $fileUri")
                }
            }
        }
        Log.i(TAG, "Orphaned image cleanup complete.")
    }

    /**
     * Checks if the app has READ_EXTERNAL_STORAGE permission.
     * @param context The application context.
     * @return True if permission is granted, false otherwise.
     */
    fun hasReadExternalStoragePermission(context: Context): Boolean {
        // Note: For Android 10 (API 29) and above, Scoped Storage largely deprecates direct
        // READ_EXTERNAL_STORAGE access for most app use cases. ContentResolver access through
        // MediaStore or DocumentProvider is preferred.
        // This check remains relevant for older Android versions or specific broader access needs.
        return ContextCompat.checkSelfPermission(
            context,
            Manifest.permission.READ_EXTERNAL_STORAGE
        ) == PackageManager.PERMISSION_GRANTED
    }

    // Utility to get a content Uri for a file, for sharing if needed
    fun getFileContentUri(context: Context, file: File): Uri? {
        val fileProviderAuthority = "${context.packageName}.fileprovider"
        return try {
            // This part requires a FileProvider setup in AndroidManifest.xml
            // For simplicity, returning Uri.fromFile for now, but usually content URI is preferred.
            Uri.fromFile(file)
        } catch (e: IllegalArgumentException) {
            Log.e(TAG, "Error getting content URI for file: ${e.message}")
            null
        }
    }

    /**
     * Helper function to convert a String to a Uri safely.
     */
    fun stringToUri(uriString: String?): Uri? {
        return uriString?.let { Uri.parse(it) }
    }

    // No direct getInternalImageUri here anymore; use CustomizationPreferences to get URI and Transformation
    // For example, CustomizationPreferences.getHeaderImageWithTransformation(context)

    /**
     * Removes an image usage entry from preferences and potentially deletes the image file.
     * @param context The application context.
     * @param usageKey The key for the image to remove.
     */
    fun removeImageUsage(context: Context, usageKey: String) {
        // Get the URI before clearing preferences for this key
        val (uriToRemove, _) = CustomizationPreferences.getImageWithTransformation(context, usageKey)

        // Clear the preference entry for this usage key
        CustomizationPreferences.clearImageWithTransformation(context, usageKey)

        // Attempt to delete the image file if it's no longer used by anything else
        uriToRemove?.let { deleteImageIfOrphaned(context, it) }

        Log.d(TAG, "Removed image usage for $usageKey and cleared preferences.")
    }
}
